(self.webpackChunkvitesandbox_client=self.webpackChunkvitesandbox_client||[]).push([[211],{19015:(e,n,t)=>{var r={"./bmp":46084,"./bmp.js":46084,"./dds":74344,"./dds.js":74344,"./gif":16727,"./gif.js":16727,"./jpg":76129,"./jpg.js":76129,"./png":27963,"./png.js":27963,"./psd":57085,"./psd.js":57085,"./svg":11445,"./svg.js":11445,"./tiff":35371,"./tiff.js":35371,"./webp":10288,"./webp.js":10288};function o(e){var n=s(e);return t(n)}function s(e){if(!t.o(r,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return r[e]}o.keys=function(){return Object.keys(r)},o.resolve=s,e.exports=o,o.id=19015},77027:e=>{function n(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=()=>[],n.resolve=n,n.id=77027,e.exports=n},1802:e=>{function n(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=()=>[],n.resolve=n,n.id=1802,e.exports=n},43366:(e,n,t)=>{"use strict";t.d(n,{k5:()=>i,vs:()=>a});var r=t(24981);let o;function s(){return o||(o=r.initialize({worker:"undefined"!=typeof Worker,wasmURL:"https://www.unpkg.com/esbuild-wasm@0.14.47/esbuild.wasm"})),o}function a(e,n){return s().then((()=>r.transform(e,n)))}function i(e,n){return s().then((()=>r.formatMessages(e,n)))}},39702:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s,promises:()=>o});var r=t(76551);const o=r.fs.promises,s=r.fs},79472:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>r});const r={}},66169:(e,n,t)=>{"use strict";t.d(n,{e:()=>o,j:()=>r});const r=["assert","async_hooks","buffer","child_process","cluster","console","constants","crypto","dgram","dns","domain","events","fs","http","http2","https","inspector","module","net","os","path","perf_hooks","process","punycode","querystring","readline","repl","stream","string_decoder","timers","tls","trace_events","tty","url","util","v8","vm","wasi","worker_threads","zlib"],o=()=>{}},69184:(e,n,t)=>{"use strict";t.d(n,{S:()=>r});const r={now:()=>(new Date).getTime()}},85379:(e,n,t)=>{"use strict";t.r(n),t.d(n,{URL:()=>o,URLSearchParams:()=>s,fileURLToPath:()=>i,parse:()=>r.Qc,pathToFileURL:()=>a});var r=t(86481);const o=globalThis.URL,s=globalThis.URLSearchParams;function a(e){return new o(e,"file://")}function i(e){if("file:"===e.protocol)return e.pathname;throw new Error(`fileURLToPath(${e})`)}},68959:(e,n,t)=>{"use strict";t.r(n);var r=t(11384),o=t(39702),s=t(26470),a=t.n(s);const i="/package.json",l="/sandbox.config.json",c="https://esm.sh",d=/^((?:@[^/A-Z:]+\/)?[^@/._A-Z:~)('!*][^@/A-Z:~)('!*]*)(?:@(.+?))?(\/[^\\/].*?)?$/,p=["tsconfig.json","jsconfig.json"],u=["react","react-dom"];function f(e){const n={imports:{}};for(const t of u){const r=e[t];n.imports[t]=r?`${c}/${t}@${r}?dev&bundle&external=${u.join(",")}`:`${c}/${t}@latest?dev&bundle&external=${u.join(",")}`}return JSON.stringify(n)}function h(e,n){try{o.default.mkdirSync(a().dirname(e),{recursive:!0}),o.default.writeFileSync(e,n)}catch(e){console.log(e)}}function m(e){if(!(l in e))return{sandboxConfigJson:{}};try{return{sandboxConfigJson:JSON.parse(e[l])}}catch(n){return e[l]="{}",n.message=`Parsing /sandbox.config.json: ${n.message}`,{sandboxConfigJson:{},parseError:n}}}function y(e){if(!(i in e))return{pkgJson:{}};try{return{pkgJson:JSON.parse(e[i])}}catch(n){return e[i]="{}",n.message=`Parsing /package.json: ${n.message}`,{pkgJson:{},parseError:n}}}function g(e,n){if(i in e){const{dependencies:t}=JSON.parse(e[i]);Object.entries(t||[]).forEach((([e,t])=>{const r=n[e];r?t!==r&&console.log(`Already pinned dependency: ${e}@${r} (${t} requested, ignored)`):n[e]=t}))}}function v(e,n,t){const{dependencies:r={},devDependencies:o={},peerDependencies:s={}}=n,a=e=>e in r||e in o||e in s;return{useReact:a("react"),useSolid:a("solid-js"),useVue:a("vue"),useSvelte:a("svelte"),useStencil:a("@stencil/core"),dependencies:r,devDependencies:o,peerDependencies:s,root:`/@root/${t}`,configFiles:Object.fromEntries(p.map((n=>[n,e[n]])))}}function b(e,n,t){const r=Array.isArray(n)?n:[n];e.publish("compile-error",{wcid:t,errors:r.map((e=>({stack:e.stack,message:e.message,filename:e.filename,lineno:e.start&&e.start.line,colno:e.start&&e.start.column})))})}function w(e,n){const t=new RegExp(`^${n}\\.(mdx?|html?|astro|njk)$`);return e.find((e=>t.test(e)))}function E(e,n,t,r){let o=`\n  import(/*@vite-ignore*/ '/${e.channelName}/vite/${r}/@vite/client').then(({ handleMessage }) => handleMessage({\n      type: 'error',\n      err: ${JSON.stringify(t)},\n  }));\n  `;return"text/html"===n&&(o=`<!DOCTYPE html><html><head><script type='module'>${o}<\/script></head><body></body></html>`),o}h("/node_modules/react-refresh/cjs/react-refresh-runtime.development.js","/* eslint-disable */\n/** @license React vundefined\n * react-refresh-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n    'use strict';\n\n    // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n    var REACT_ELEMENT_TYPE = 0xeac7;\n    var REACT_PORTAL_TYPE = 0xeaca;\n    var REACT_FRAGMENT_TYPE = 0xeacb;\n    var REACT_STRICT_MODE_TYPE = 0xeacc;\n    var REACT_PROFILER_TYPE = 0xead2;\n    var REACT_PROVIDER_TYPE = 0xeacd;\n    var REACT_CONTEXT_TYPE = 0xeace;\n    var REACT_FORWARD_REF_TYPE = 0xead0;\n    var REACT_SUSPENSE_TYPE = 0xead1;\n    var REACT_SUSPENSE_LIST_TYPE = 0xead8;\n    var REACT_MEMO_TYPE = 0xead3;\n    var REACT_LAZY_TYPE = 0xead4;\n    var REACT_SCOPE_TYPE = 0xead7;\n    var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\n    var REACT_OFFSCREEN_TYPE = 0xeae2;\n    var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\n    var REACT_CACHE_TYPE = 0xeae4;\n\n    if (typeof Symbol === 'function' && Symbol.for) {\n      var symbolFor = Symbol.for;\n      REACT_ELEMENT_TYPE = symbolFor('react.element');\n      REACT_PORTAL_TYPE = symbolFor('react.portal');\n      REACT_FRAGMENT_TYPE = symbolFor('react.fragment');\n      REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\n      REACT_PROFILER_TYPE = symbolFor('react.profiler');\n      REACT_PROVIDER_TYPE = symbolFor('react.provider');\n      REACT_CONTEXT_TYPE = symbolFor('react.context');\n      REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n      REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\n      REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\n      REACT_MEMO_TYPE = symbolFor('react.memo');\n      REACT_LAZY_TYPE = symbolFor('react.lazy');\n      REACT_SCOPE_TYPE = symbolFor('react.scope');\n      REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\n      REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\n      REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\n      REACT_CACHE_TYPE = symbolFor('react.cache');\n    }\n\n    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.\n    // It's OK to reference families, but use WeakMap/Set for types.\n\n    var allFamiliesByID = new Map();\n    var allFamiliesByType = new PossiblyWeakMap();\n    var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families\n    // that have actually been edited here. This keeps checks fast.\n    // $FlowIssue\n\n    var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.\n    // It is an array of [Family, NextType] tuples.\n\n    var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.\n\n    var helpersByRendererID = new Map();\n    var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.\n\n    var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.\n\n    var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.\n    // It needs to be weak because we do this even for roots that failed to mount.\n    // If there is no WeakMap, we won't attempt to do retrying.\n    // $FlowIssue\n\n    var rootElements = // $FlowIssue\ntypeof WeakMap === 'function' ? new WeakMap() : null;\n    var isPerformingRefresh = false;\n\n    function computeFullKey(signature) {\n      if (signature.fullKey !== null) {\n        return signature.fullKey;\n      }\n\n      var fullKey = signature.ownKey;\n      var hooks;\n\n      try {\n        hooks = signature.getCustomHooks();\n      } catch (err) {\n        // This can happen in an edge case, e.g. if expression like Foo.useSomething\n        // depends on Foo which is lazily initialized during rendering.\n        // In that case just assume we'll have to remount.\n        signature.forceReset = true;\n        signature.fullKey = fullKey;\n        return fullKey;\n      }\n\n      for (var i = 0; i < hooks.length; i++) {\n        var hook = hooks[i];\n\n        if (typeof hook !== 'function') {\n          // Something's wrong. Assume we need to remount.\n          signature.forceReset = true;\n          signature.fullKey = fullKey;\n          return fullKey;\n        }\n\n        var nestedHookSignature = allSignaturesByType.get(hook);\n\n        if (nestedHookSignature === undefined) {\n          // No signature means Hook wasn't in the source code, e.g. in a library.\n          // We'll skip it because we can assume it won't change during this session.\n          continue;\n        }\n\n        var nestedHookKey = computeFullKey(nestedHookSignature);\n\n        if (nestedHookSignature.forceReset) {\n          signature.forceReset = true;\n        }\n\n        fullKey += '\\\\n---\\\\n' + nestedHookKey;\n      }\n\n      signature.fullKey = fullKey;\n      return fullKey;\n    }\n\n    function haveEqualSignatures(prevType, nextType) {\n      var prevSignature = allSignaturesByType.get(prevType);\n      var nextSignature = allSignaturesByType.get(nextType);\n\n      if (prevSignature === undefined && nextSignature === undefined) {\n        return true;\n      }\n\n      if (prevSignature === undefined || nextSignature === undefined) {\n        return false;\n      }\n\n      if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n        return false;\n      }\n\n      if (nextSignature.forceReset) {\n        return false;\n      }\n\n      return true;\n    }\n\n    function isReactClass(type) {\n      return type.prototype && type.prototype.isReactComponent;\n    }\n\n    function canPreserveStateBetween(prevType, nextType) {\n      if (isReactClass(prevType) || isReactClass(nextType)) {\n        return false;\n      }\n\n      if (haveEqualSignatures(prevType, nextType)) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function resolveFamily(type) {\n      // Only check updated types to keep lookups fast.\n      return updatedFamiliesByType.get(type);\n    } // If we didn't care about IE11, we could use new Map/Set(iterable).\n\n\n    function cloneMap(map) {\n      var clone = new Map();\n      map.forEach(function (value, key) {\n        clone.set(key, value);\n      });\n      return clone;\n    }\n\n    function cloneSet(set) {\n      var clone = new Set();\n      set.forEach(function (value) {\n        clone.add(value);\n      });\n      return clone;\n    } // This is a safety mechanism to protect against rogue getters and Proxies.\n\n\n    function getProperty(object, property) {\n      try {\n        return object[property];\n      } catch (err) {\n        // Intentionally ignore.\n        return undefined;\n      }\n    }\n\n    function performReactRefresh() {\n\n      if (pendingUpdates.length === 0) {\n        return null;\n      }\n\n      if (isPerformingRefresh) {\n        return null;\n      }\n\n      isPerformingRefresh = true;\n\n      try {\n        var staleFamilies = new Set();\n        var updatedFamilies = new Set();\n        var updates = pendingUpdates;\n        pendingUpdates = [];\n        updates.forEach(function (_ref) {\n          var family = _ref[0],\n            nextType = _ref[1];\n          // Now that we got a real edit, we can create associations\n          // that will be read by the React reconciler.\n          var prevType = family.current;\n          updatedFamiliesByType.set(prevType, family);\n          updatedFamiliesByType.set(nextType, family);\n          family.current = nextType; // Determine whether this should be a re-render or a re-mount.\n\n          if (canPreserveStateBetween(prevType, nextType)) {\n            updatedFamilies.add(family);\n          } else {\n            staleFamilies.add(family);\n          }\n        }); // TODO: rename these fields to something more meaningful.\n\n        var update = {\n          updatedFamilies: updatedFamilies,\n          // Families that will re-render preserving state\n          staleFamilies: staleFamilies // Families that will be remounted\n\n        };\n        helpersByRendererID.forEach(function (helpers) {\n          // Even if there are no roots, set the handler on first update.\n          // This ensures that if *new* roots are mounted, they'll use the resolve handler.\n          helpers.setRefreshHandler(resolveFamily);\n        });\n        var didError = false;\n        var firstError = null; // We snapshot maps and sets that are mutated during commits.\n        // If we don't do this, there is a risk they will be mutated while\n        // we iterate over them. For example, trying to recover a failed root\n        // may cause another root to be added to the failed list -- an infinite loop.\n\n        var failedRootsSnapshot = cloneSet(failedRoots);\n        var mountedRootsSnapshot = cloneSet(mountedRoots);\n        var helpersByRootSnapshot = cloneMap(helpersByRoot);\n        failedRootsSnapshot.forEach(function (root) {\n          var helpers = helpersByRootSnapshot.get(root);\n\n          if (helpers === undefined) {\n            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n          }\n\n          if (!failedRoots.has(root)) {// No longer failed.\n          }\n\n          if (rootElements === null) {\n            return;\n          }\n\n          if (!rootElements.has(root)) {\n            return;\n          }\n\n          var element = rootElements.get(root);\n\n          try {\n            helpers.scheduleRoot(root, element);\n          } catch (err) {\n            if (!didError) {\n              didError = true;\n              firstError = err;\n            } // Keep trying other roots.\n\n          }\n        });\n        mountedRootsSnapshot.forEach(function (root) {\n          var helpers = helpersByRootSnapshot.get(root);\n\n          if (helpers === undefined) {\n            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n          }\n\n          if (!mountedRoots.has(root)) {// No longer mounted.\n          }\n\n          try {\n            helpers.scheduleRefresh(root, update);\n          } catch (err) {\n            if (!didError) {\n              didError = true;\n              firstError = err;\n            } // Keep trying other roots.\n\n          }\n        });\n\n        if (didError) {\n          throw firstError;\n        }\n\n        return update;\n      } finally {\n        isPerformingRefresh = false;\n      }\n    }\n    function register(type, id) {\n      {\n        if (type === null) {\n          return;\n        }\n\n        if (typeof type !== 'function' && typeof type !== 'object') {\n          return;\n        } // This can happen in an edge case, e.g. if we register\n        // return value of a HOC but it returns a cached component.\n        // Ignore anything but the first registration for each type.\n\n\n        if (allFamiliesByType.has(type)) {\n          return;\n        } // Create family or remember to update it.\n        // None of this bookkeeping affects reconciliation\n        // until the first performReactRefresh() call above.\n\n\n        var family = allFamiliesByID.get(id);\n\n        if (family === undefined) {\n          family = {\n            current: type\n          };\n          allFamiliesByID.set(id, family);\n        } else {\n          pendingUpdates.push([family, type]);\n        }\n\n        allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.\n\n        if (typeof type === 'object' && type !== null) {\n          switch (getProperty(type, '$$typeof')) {\n          case REACT_FORWARD_REF_TYPE:\n            register(type.render, id + '$render');\n            break;\n\n          case REACT_MEMO_TYPE:\n            register(type.type, id + '$type');\n            break;\n          }\n        }\n      }\n    }\n    function setSignature(type, key) {\n      var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;\n\n      {\n        if (!allSignaturesByType.has(type)) {\n          allSignaturesByType.set(type, {\n            forceReset: forceReset,\n            ownKey: key,\n            fullKey: null,\n            getCustomHooks: getCustomHooks || function () {\n              return [];\n            }\n          });\n        } // Visit inner types because we might not have signed them.\n\n\n        if (typeof type === 'object' && type !== null) {\n          switch (getProperty(type, '$$typeof')) {\n          case REACT_FORWARD_REF_TYPE:\n            setSignature(type.render, key, forceReset, getCustomHooks);\n            break;\n\n          case REACT_MEMO_TYPE:\n            setSignature(type.type, key, forceReset, getCustomHooks);\n            break;\n          }\n        }\n      }\n    } // This is lazily called during first render for a type.\n    // It captures Hook list at that time so inline requires don't break comparisons.\n\n    function collectCustomHooksForSignature(type) {\n      {\n        var signature = allSignaturesByType.get(type);\n\n        if (signature !== undefined) {\n          computeFullKey(signature);\n        }\n      }\n    }\n    function getFamilyByID(id) {\n      {\n        return allFamiliesByID.get(id);\n      }\n    }\n    function getFamilyByType(type) {\n      {\n        return allFamiliesByType.get(type);\n      }\n    }\n    function findAffectedHostInstances(families) {\n      {\n        var affectedInstances = new Set();\n        mountedRoots.forEach(function (root) {\n          var helpers = helpersByRoot.get(root);\n\n          if (helpers === undefined) {\n            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n          }\n\n          var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\n          instancesForRoot.forEach(function (inst) {\n            affectedInstances.add(inst);\n          });\n        });\n        return affectedInstances;\n      }\n    }\n    function injectIntoGlobalHook(globalObject) {\n      {\n        // For React Native, the global hook will be set up by require('react-devtools-core').\n        // That code will run before us. So we need to monkeypatch functions on existing hook.\n        // For React Web, the global hook will be set up by the extension.\n        // This will also run before us.\n        var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n        if (hook === undefined) {\n          // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.\n          // Note that in this case it's important that renderer code runs *after* this method call.\n          // Otherwise, the renderer will think that there is no global hook, and won't do the injection.\n          var nextID = 0;\n          globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n            renderers: new Map(),\n            supportsFiber: true,\n            inject: function (injected) {\n              return nextID++;\n            },\n            onScheduleFiberRoot: function (id, root, children) {},\n            onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},\n            onCommitFiberUnmount: function () {}\n          };\n        }\n\n        if (hook.isDisabled) {\n          // This isn't a real property on the hook, but it can be set to opt out\n          // of DevTools integration and associated warnings and logs.\n          // Using console['warn'] to evade Babel and ESLint\n          console['warn']('Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' + 'Fast Refresh is not compatible with this shim and will be disabled.');\n          return;\n        } // Here, we just want to get a reference to scheduleRefresh.\n\n\n        var oldInject = hook.inject;\n\n        hook.inject = function (injected) {\n          var id = oldInject.apply(this, arguments);\n\n          if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n            // This version supports React Refresh.\n            helpersByRendererID.set(id, injected);\n          }\n\n          return id;\n        }; // Do the same for any already injected roots.\n        // This is useful if ReactDOM has already been initialized.\n        // https://github.com/facebook/react/issues/17626\n\n\n        hook.renderers.forEach(function (injected, id) {\n          if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n            // This version supports React Refresh.\n            helpersByRendererID.set(id, injected);\n          }\n        }); // We also want to track currently mounted roots.\n\n        var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n\n        var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function () {};\n\n        hook.onScheduleFiberRoot = function (id, root, children) {\n          if (!isPerformingRefresh) {\n            // If it was intentionally scheduled, don't attempt to restore.\n            // This includes intentionally scheduled unmounts.\n            failedRoots.delete(root);\n\n            if (rootElements !== null) {\n              rootElements.set(root, children);\n            }\n          }\n\n          return oldOnScheduleFiberRoot.apply(this, arguments);\n        };\n\n        hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {\n          var helpers = helpersByRendererID.get(id);\n\n          if (helpers !== undefined) {\n            helpersByRoot.set(root, helpers);\n            var current = root.current;\n            var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.\n            // This logic is copy-pasted from similar logic in the DevTools backend.\n            // If this breaks with some refactoring, you'll want to update DevTools too.\n\n            if (alternate !== null) {\n              var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;\n              var isMounted = current.memoizedState != null && current.memoizedState.element != null;\n\n              if (!wasMounted && isMounted) {\n                // Mount a new root.\n                mountedRoots.add(root);\n                failedRoots.delete(root);\n              } else if (wasMounted && isMounted) ; else if (wasMounted && !isMounted) {\n                // Unmount an existing root.\n                mountedRoots.delete(root);\n\n                if (didError) {\n                  // We'll remount it on future edits.\n                  failedRoots.add(root);\n                } else {\n                  helpersByRoot.delete(root);\n                }\n              } else if (!wasMounted && !isMounted) {\n                if (didError) {\n                  // We'll remount it on future edits.\n                  failedRoots.add(root);\n                }\n              }\n            } else {\n              // Mount a new root.\n              mountedRoots.add(root);\n            }\n          } // Always call the decorated DevTools hook.\n\n\n          return oldOnCommitFiberRoot.apply(this, arguments);\n        };\n      }\n    }\n    function hasUnrecoverableErrors() {\n      // TODO: delete this after removing dependency in RN.\n      return false;\n    } // Exposed for testing.\n\n    function _getMountedRootCount() {\n      {\n        return mountedRoots.size;\n      }\n    } // This is a wrapper over more primitive functions for setting signature.\n    // Signatures let us decide whether the Hook order has changed on refresh.\n    //\n    // This function is intended to be used as a transform target, e.g.:\n    // var _s = createSignatureFunctionForTransform()\n    //\n    // function Hello() {\n    //   const [foo, setFoo] = useState(0);\n    //   const value = useCustomHook();\n    //   _s(); /* Call without arguments triggers collecting the custom Hook list.\n    //          * This doesn't happen during the module evaluation because we\n    //          * don't want to change the module order with inline requires.\n    //          * Next calls are noops. */\n    //   return <h1>Hi</h1>;\n    // }\n    //\n    // /* Call with arguments attaches the signature to the type: */\n    // _s(\n    //   Hello,\n    //   'useState{[foo, setFoo]}(0)',\n    //   () => [useCustomHook], /* Lazy to avoid triggering inline requires */\n    // );\n\n    function createSignatureFunctionForTransform() {\n      {\n        var savedType;\n        var hasCustomHooks;\n        var didCollectHooks = false;\n        return function (type, key, forceReset, getCustomHooks) {\n          if (typeof key === 'string') {\n            // We're in the initial phase that associates signatures\n            // with the functions. Note this may be called multiple times\n            // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).\n            if (!savedType) {\n              // We're in the innermost call, so this is the actual type.\n              savedType = type;\n              hasCustomHooks = typeof getCustomHooks === 'function';\n            } // Set the signature for all types (even wrappers!) in case\n            // they have no signatures of their own. This is to prevent\n            // problems like https://github.com/facebook/react/issues/20417.\n\n\n            if (type != null && (typeof type === 'function' || typeof type === 'object')) {\n              setSignature(type, key, forceReset, getCustomHooks);\n            }\n\n            return type;\n          } else {\n            // We're in the _s() call without arguments, which means\n            // this is the time to collect custom Hook signatures.\n            // Only do this once. This path is hot and runs *inside* every render!\n            if (!didCollectHooks && hasCustomHooks) {\n              didCollectHooks = true;\n              collectCustomHooksForSignature(savedType);\n            }\n          }\n        };\n      }\n    }\n    function isLikelyComponentType(type) {\n      {\n        switch (typeof type) {\n        case 'function':\n        {\n          // First, deal with classes.\n          if (type.prototype != null) {\n            if (type.prototype.isReactComponent) {\n              // React class.\n              return true;\n            }\n\n            var ownNames = Object.getOwnPropertyNames(type.prototype);\n\n            if (ownNames.length > 1 || ownNames[0] !== 'constructor') {\n              // This looks like a class.\n              return false;\n            } // eslint-disable-next-line no-proto\n\n\n            if (type.prototype.__proto__ !== Object.prototype) {\n              // It has a superclass.\n              return false;\n            } // Pass through.\n            // This looks like a regular function with empty prototype.\n\n          } // For plain functions and arrows, use name as a heuristic.\n\n\n          var name = type.name || type.displayName;\n          return typeof name === 'string' && /^[A-Z]/.test(name);\n        }\n\n        case 'object':\n        {\n          if (type != null) {\n            switch (getProperty(type, '$$typeof')) {\n            case REACT_FORWARD_REF_TYPE:\n            case REACT_MEMO_TYPE:\n              // Definitely React components.\n              return true;\n\n            default:\n              return false;\n            }\n          }\n\n          return false;\n        }\n\n        default:\n        {\n          return false;\n        }\n        }\n      }\n    }\n\n    exports._getMountedRootCount = _getMountedRootCount;\n    exports.collectCustomHooksForSignature = collectCustomHooksForSignature;\n    exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;\n    exports.findAffectedHostInstances = findAffectedHostInstances;\n    exports.getFamilyByID = getFamilyByID;\n    exports.getFamilyByType = getFamilyByType;\n    exports.hasUnrecoverableErrors = hasUnrecoverableErrors;\n    exports.injectIntoGlobalHook = injectIntoGlobalHook;\n    exports.isLikelyComponentType = isLikelyComponentType;\n    exports.performReactRefresh = performReactRefresh;\n    exports.register = register;\n    exports.setSignature = setSignature;\n  })();\n}\n");var T=t(28941),k=t.n(T),R=t(96602),_=t(53892);const x=({tree:e})=>{let n;return{name:"vite:node:resolve",enforce:"pre",configureServer(e){n=e},resolveId(t,r,{ssr:o}){if(/dist\/__require\.js$/.test(t))return"/dist/__require.js";const s=d.exec(t);if(s){if(o)return{id:t,external:!0};const{_optimizeDepsMetadata:r}=n;if(r){const e=r.optimized[t];if(e?.src)return{id:e.file,external:!0}}const[,a,,i]=s,{pkgJson:l,parseError:c}=y(e);if(!c){const{dependencies:e}=l;if(!e[a])throw new Error(`${a} not implicited in package.json`);return{id:`https://esm.sh/${a}@${e[a]}${i}`,external:!0}}}},load(e){if("/dist/__require.js"===e)return n?._optimizeDepsMetadata?`\n            export default function require(library) {\n              const flat = library.replace(/[\\/\\.]/g, '_');\n              return import(/*@vite-ignore*/ ${JSON.stringify(c)}+flat).then(m => ({...m, ...m.default}));\n            }\n        `:(console.warn("Trying to access dynamic require but dependencies aren't optimized yet"),"\n            export default function require(library) {\n                throw new Error('Missing library: ' + library)\n            }")}}},S=({tree:e})=>({name:"vite:html:transform",transformIndexHtml:{enforce:"pre",transform(n){const t={};g(e,t);const r=[{tag:"script",attrs:{type:"importmap"},children:f(t)},{tag:"script",attrs:{type:"text/javascript"},children:"\n  try {\n    // 修改 domain，以便让外部页面和 iframe 页面在同一个域名下，主要目的是为了直接监听 iframe 页面的事件 xxx\n    document.domain = window.location.hostname.split('.').slice(-2).join('.');\n  } catch (error) {\n    //\n  }\n"}],{sandboxConfigJson:o,parseError:s}=m(e);return s||(o.evaluateJavaScript&&r.push({tag:"script",attrs:{type:"text/javascript"},children:o.evaluateJavaScript}),o.externalResources&&Array.isArray(o.externalResources)&&o.externalResources.forEach((e=>{!function(e){const n=new URL(e).pathname.match(/\.([^.]*)$/);return n&&"css"===n[1]||e.includes("fonts.googleapis")}(e)?r.push({tag:"script",attrs:{id:"external-js",async:!1,src:e}}):r.push({tag:"link",attrs:{id:"external-css",rel:"stylesheet",type:"text/css",href:e,media:"all"}})}))),{html:n,tags:r}}}}),C=(e,n,t)=>{const{sandboxConfigJson:r,parseError:o}=m(t);return!o&&r.npmUrlMap&&r.npmUrlMap[e]?r.npmUrlMap[e]:`${c}/${e}@${n[e]}?bundle&dev&external=${u.join(",")}`};async function M(e,n,t){const r={hash:"0",browserHash:"0",optimized:{}},o={};g(n,o);for(const e of Object.keys(o))r.optimized[e]={file:C(e,o,n),needsInterop:!1};return r}const F=async function(e,{cfg:n,wc:t,baseUrl:o},s){const i=[R.default],l=[{name:"vite:browser:hmr",enforce:"pre",resolveId(e){if(e.startsWith(r._9))return{id:/\.mjs$/.test(e)?e:`${e}.mjs`,external:!0}},load:e=>e===r.j2?"/* eslint-disable no-undef */\nimport '@vite/env';\n\nconst template = /*html*/ `\n<style>\n:host {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n  --monospace: 'SFMono-Regular', Consolas,\n              'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  width: 800px;\n  color: #d8d8d8;\n  margin: 30px auto;\n  padding: 25px 40px;\n  position: relative;\n  background: #181818;\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n</style>\n<div class=\"window\">\n  <pre class=\"message\"><span class=\"plugin\"></span><span class=\"message-body\"></span></pre>\n  <pre class=\"file\"></pre>\n  <pre class=\"frame\"></pre>\n  <pre class=\"stack\"></pre>\n  <div class=\"tip\">\n    Click outside or fix the code to dismiss.<br>\n    You can also disable this overlay by setting\n    <code>server.hmr.overlay</code> to <code>false</code> in <code>vite.config.js.</code>\n  </div>\n</div>\n`;\nconst fileRE = /(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s+\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\nclass ErrorOverlay extends HTMLElement {\n  constructor(err) {\n    var _a;\n    super();\n    this.root = this.attachShadow({ mode: 'open' });\n    this.root.innerHTML = template;\n    codeframeRE.lastIndex = 0;\n    const hasFrame = err.frame && codeframeRE.test(err.frame);\n    const message = hasFrame\n      ? err.message.replace(codeframeRE, '')\n      : err.message;\n    if (err.plugin) {\n      this.text('.plugin', `[plugin:${err.plugin}] `);\n    }\n    this.text('.message-body', message.trim());\n    const [file] = (((_a = err.loc) === null || _a === void 0 ? void 0 : _a.file) || err.id || 'unknown file').split('?');\n    if (err.loc) {\n      this.text('.file', `${file}:${err.loc.line}:${err.loc.column}`, true);\n    }\n    else if (err.id) {\n      this.text('.file', file);\n    }\n    if (hasFrame) {\n      this.text('.frame', err.frame.trim());\n    }\n    this.text('.stack', err.stack, true);\n    this.root.querySelector('.window').addEventListener('click', (e) => {\n      e.stopPropagation();\n    });\n    this.addEventListener('click', () => {\n      this.close();\n    });\n  }\n  text(selector, text, linkFiles = false) {\n    const el = this.root.querySelector(selector);\n    if (!linkFiles) {\n      el.textContent = text;\n    }\n    else {\n      let curIndex = 0;\n      let match;\n      while ((match = fileRE.exec(text))) {\n        const { 0: file, index } = match;\n        if (index != null) {\n          const frag = text.slice(curIndex, index);\n          el.appendChild(document.createTextNode(frag));\n          const link = document.createElement('a');\n          link.textContent = file;\n          link.className = 'file-link';\n          link.onclick = () => {\n            fetch('/__open-in-editor?file=' + encodeURIComponent(file));\n          };\n          el.appendChild(link);\n          curIndex += frag.length + file.length;\n        }\n      }\n    }\n  }\n  close() {\n    var _a;\n    (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this);\n  }\n}\nconst overlayId = 'vite-error-overlay';\nif (customElements && !customElements.get(overlayId)) {\n  customElements.define(overlayId, ErrorOverlay);\n}\n\nconsole.log('[vite] connecting...');\n// use server configuration, then fallback to inference\nconst base = __BASE__ || '/';\nfunction warnFailedFetch(err, path) {\n  if (!err.message.match('fetch')) {\n    console.error(err);\n  }\n  console.error(`[hmr] Failed to reload ${path}. ` +\n        'This could be due to syntax errors or importing non-existent ' +\n        'modules. (see errors above)');\n}\nlet isFirstUpdate = true;\nasync function handleMessage(payload) {\n  console.log(payload, 'client 接收到 hmr 消息');\n  switch (payload.type) {\n  case 'connected':\n    console.log('[vite] connected.');\n    // proxy(nginx, docker) hmr ws maybe caused timeout,\n    // so send ping package let ws keep alive.\n    break;\n  case 'update':\n    notifyListeners('vite:beforeUpdate', payload);\n    // if this is the first update and there's already an error overlay, it\n    // means the page opened with existing server compile error and the whole\n    // module script failed to load (since one of the nested imports is 500).\n    // in this case a normal update won't work and a full reload is needed.\n    if (isFirstUpdate && hasErrorOverlay()) {\n      window.location.reload();\n      return;\n    }\n    else {\n      clearErrorOverlay();\n      isFirstUpdate = false;\n    }\n    payload.updates.forEach((update) => {\n      if (update.type === 'js-update') {\n        queueUpdate(fetchUpdate(update));\n      }\n      else {\n        // css-update\n        // this is only sent when a css file referenced with <link> is updated\n        let { path, timestamp } = update;\n        path = path.replace(/\\?.*/, '');\n        // can't use querySelector with `[href*=]` here since the link may be\n        // using relative paths so we need to use link.href to grab the full\n        // URL for the include check.\n        const el = Array.from(document.querySelectorAll('link')).find((e) => e.href.includes(path));\n        if (el) {\n          const newPath = `${base}${path.slice(1)}${path.includes('?') ? '&' : '?'}t=${timestamp}`;\n          el.href = new URL(newPath, el.href).href;\n        }\n        console.log(`[vite] css hot updated: ${path}`);\n      }\n    });\n    break;\n  case 'custom': {\n    notifyListeners(payload.event, payload.data);\n    break;\n  }\n  case 'full-reload':\n    notifyListeners('vite:beforeFullReload', payload);\n    if (payload.path && payload.path.endsWith('.html')) {\n      // if html file is edited, only reload the page if the browser is\n      // currently on that page.\n      const pagePath = location.pathname;\n      const payloadPath = base + payload.path.slice(1);\n      if (pagePath === payloadPath ||\n                    (pagePath.endsWith('/') && pagePath + 'index.html' === payloadPath)) {\n        console.log('location.reload 1');\n        location.reload();\n      }\n      return;\n    }\n    else {\n      console.log('location.reload 2');\n      location.reload();\n    }\n    break;\n  case 'prune':\n    notifyListeners('vite:beforePrune', payload);\n    // After an HMR update, some modules are no longer imported on the page\n    // but they may have left behind side effects that need to be cleaned up\n    // (.e.g style injections)\n    // TODO Trigger their dispose callbacks.\n    payload.paths.forEach((path) => {\n      const fn = pruneMap.get(path);\n      if (fn) {\n        fn(dataMap.get(path));\n      }\n    });\n    break;\n  case 'error': {\n    notifyListeners('vite:error', payload);\n    const err = payload.err;\n    if (enableOverlay) {\n      createErrorOverlay(err);\n    }\n    else {\n      console.error(`[vite] Internal Server Error\\n${err.message}\\n${err.stack}`);\n    }\n    break;\n  }\n  default: {\n    const check = payload;\n    return check;\n  }\n  }\n}\nfunction notifyListeners(event, data) {\n  const cbs = customListenersMap.get(event);\n  if (cbs) {\n    cbs.forEach((cb) => cb(data));\n  }\n}\nconst enableOverlay = __HMR_ENABLE_OVERLAY__;\nfunction createErrorOverlay(err) {\n  if (!enableOverlay)\n    return;\n  clearErrorOverlay();\n  document.body.appendChild(new ErrorOverlay(err));\n}\nfunction clearErrorOverlay() {\n  document\n    .querySelectorAll(overlayId)\n    .forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n  return document.querySelectorAll(overlayId).length;\n}\nlet pending = false;\nlet queued = [];\n/**\n * buffer multiple hot updates triggered by the same src change\n * so that they are invoked in the same order they were sent.\n * (otherwise the order may be inconsistent because of the http request round trip)\n */\nasync function queueUpdate(p) {\n  queued.push(p);\n  if (!pending) {\n    pending = true;\n    await Promise.resolve();\n    pending = false;\n    const loading = [...queued];\n    queued = [];\n    (await Promise.all(loading)).forEach((fn) => fn && fn());\n  }\n}\nconst sheetsMap = new Map();\nfunction updateStyle(id, content) {\n  let style = sheetsMap.get(id);\n  {\n    if (style && !(style instanceof HTMLStyleElement)) {\n      removeStyle(id);\n      style = undefined;\n    }\n    if (!style) {\n      style = document.createElement('style');\n      style.setAttribute('type', 'text/css');\n      style.setAttribute('id', id);\n      style.innerHTML = content;\n      document.head.appendChild(style);\n    }\n    else {\n      style.innerHTML = content;\n    }\n  }\n  sheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n  const style = sheetsMap.get(id);\n  if (style) {\n    if (style instanceof CSSStyleSheet) {\n      // @ts-ignore\n      document.adoptedStyleSheets = document.adoptedStyleSheets.filter((s) => s !== style);\n    }\n    else {\n      document.head.removeChild(style);\n    }\n    sheetsMap.delete(id);\n  }\n}\nasync function fetchUpdate({ path, acceptedPath, timestamp }) {\n  const mod = hotModulesMap.get(path);\n  if (!mod) {\n    // In a code-splitting project,\n    // it is common that the hot-updating module is not loaded yet.\n    // https://github.com/vitejs/vite/issues/721\n    return;\n  }\n  const moduleMap = new Map();\n  const isSelfUpdate = path === acceptedPath;\n  // make sure we only import each dep once\n  const modulesToUpdate = new Set();\n  if (isSelfUpdate) {\n    // self update - only update self\n    modulesToUpdate.add(path);\n  }\n  else {\n    // dep update\n    for (const { deps } of mod.callbacks) {\n      deps.forEach((dep) => {\n        if (acceptedPath === dep) {\n          modulesToUpdate.add(dep);\n        }\n      });\n    }\n  }\n  // determine the qualified callbacks before we re-import the modules\n  const qualifiedCallbacks = mod.callbacks.filter(({ deps }) => {\n    return deps.some((dep) => modulesToUpdate.has(dep));\n  });\n  await Promise.all(Array.from(modulesToUpdate).map(async (dep) => {\n    const disposer = disposeMap.get(dep);\n    if (disposer)\n      await disposer(dataMap.get(dep));\n    const [path, query] = dep.split('?');\n    try {\n      const newMod = await import(\n        /* @vite-ignore */\n        base +\n                path.slice(1) +\n                `?import&t=${timestamp}${query ? `&${query}` : ''}`);\n      moduleMap.set(dep, newMod);\n    }\n    catch (e) {\n      warnFailedFetch(e, dep);\n    }\n  }));\n  return () => {\n    for (const { deps, fn } of qualifiedCallbacks) {\n      fn(deps.map((dep) => moduleMap.get(dep)));\n    }\n    const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n    console.log(`[vite] hot updated: ${loggedPath}`);\n  };\n}\nconst hotModulesMap = new Map();\nconst disposeMap = new Map();\nconst pruneMap = new Map();\nconst dataMap = new Map();\nconst customListenersMap = new Map();\nconst ctxToListenersMap = new Map();\n// Just infer the return type for now\nconst createHotContext = (ownerPath) => {\n  if (!dataMap.has(ownerPath)) {\n    dataMap.set(ownerPath, {});\n  }\n  // when a file is hot updated, a new context is created\n  // clear its stale callbacks\n  const mod = hotModulesMap.get(ownerPath);\n  if (mod) {\n    mod.callbacks = [];\n  }\n  // clear stale custom event listeners\n  const staleListeners = ctxToListenersMap.get(ownerPath);\n  if (staleListeners) {\n    for (const [event, staleFns] of staleListeners) {\n      const listeners = customListenersMap.get(event);\n      if (listeners) {\n        customListenersMap.set(event, listeners.filter((l) => !staleFns.includes(l)));\n      }\n    }\n  }\n  const newListeners = new Map();\n  ctxToListenersMap.set(ownerPath, newListeners);\n  function acceptDeps(deps, callback = () => { }) {\n    const mod = hotModulesMap.get(ownerPath) || {\n      id: ownerPath,\n      callbacks: []\n    };\n    mod.callbacks.push({\n      deps,\n      fn: callback\n    });\n    hotModulesMap.set(ownerPath, mod);\n  }\n  const hot = {\n    get data() {\n      return dataMap.get(ownerPath);\n    },\n    accept(deps, callback) {\n      if (typeof deps === 'function' || !deps) {\n        // self-accept: hot.accept(() => {})\n        acceptDeps([ownerPath], ([mod]) => deps && deps(mod));\n      }\n      else if (typeof deps === 'string') {\n        // explicit deps\n        acceptDeps([deps], ([mod]) => callback && callback(mod));\n      }\n      else if (Array.isArray(deps)) {\n        acceptDeps(deps, callback);\n      }\n      else {\n        throw new Error('invalid hot.accept() usage.');\n      }\n    },\n    acceptDeps() {\n      throw new Error('hot.acceptDeps() is deprecated. ' +\n                'Use hot.accept() with the same signature instead.');\n    },\n    dispose(cb) {\n      disposeMap.set(ownerPath, cb);\n    },\n    prune(cb) {\n      pruneMap.set(ownerPath, cb);\n    },\n    // TODO\n    decline() { },\n    invalidate() {\n      // TODO should tell the server to re-perform hmr propagation\n      // from this module as root\n      location.reload();\n    },\n    // custom events\n    on: (event, cb) => {\n      const addToMap = (map) => {\n        const existing = map.get(event) || [];\n        existing.push(cb);\n        map.set(event, existing);\n      };\n      addToMap(customListenersMap);\n      addToMap(newListeners);\n    }\n  };\n  return hot;\n};\n/**\n * urls here are dynamic import() urls that couldn't be statically analyzed\n */\nfunction injectQuery(url, queryToInject) {\n  // skip urls that won't be handled by vite\n  if (!url.startsWith('.') && !url.startsWith('/')) {\n    return url;\n  }\n  // can't use pathname from URL since it may be relative like ../\n  const pathname = url.replace(/#.*$/, '').replace(/\\?.*$/, '');\n  const { search, hash } = new URL(url, 'http://vitejs.dev');\n  return `${pathname}?${queryToInject}${search ? '&' + search.slice(1) : ''}${hash || ''}`;\n}\n\n// 更新 stylex - css 原子化\nfunction handleStylexUpdate(payload) {\n  updateStyle('stylex-css', payload.styleContent);\n}\n\nclass Channel {\n  constructor(channelName) {\n    this.channelName = channelName;\n    this.listeners = new Map();\n    this.broadcastChannel = new BroadcastChannel(channelName);\n    this.broadcastChannel.addEventListener('message', this.onEvent.bind(this));\n  }\n\n  subscribe(type, callback) {\n    let callbacks = this.listeners.get(type);\n\n    if (!callbacks) {\n      callbacks = new Set();\n      this.listeners.set(type, callbacks);\n    }\n\n    callbacks.add(callback);\n\n    return () => {\n      const callbacks = this.listeners.get(type);\n      if (callbacks) {\n        callbacks.delete(callback);\n      }\n    };\n  }\n\n  request(originType = 'serve-request', data) {\n    const reqId = Date.now().toString(36);\n    const type = originType.toString().replace('request', 'response');\n\n    return new Promise(resolve => {\n      const clear = this.subscribe(type, response => {\n        if (response.reqId === reqId) {\n          clear();\n          delete response.reqId;\n          resolve(response.result);\n        }\n      });\n\n      this.publish(originType, { ...data, reqId });\n    });\n  }\n\n  publish(type, data) {\n    this.broadcastChannel.postMessage({\n      type,\n      data\n    });\n  }\n\n  onEvent(event) {\n    this.notifyListeners(event.data.type, event.data.data);\n  }\n\n  notifyListeners(type, data) {\n    const callbacks = this.listeners.get(type);\n    if (callbacks) {\n      callbacks.forEach(callback=>{\n        try {\n          callback(data);\n        } catch (err) {\n          console.error(err);\n        }\n      });\n    }\n  }\n}\n\nconst [, busid] = /^https?:\\/\\/[^]*\\/([^/]{32})\\/vite\\/([^/]*)(\\/.*)$/.exec(window.location.href);\n\nconst channel = new Channel(busid);\n\nchannel.subscribe('vite-hmr', handleMessage);\n\nchannel.subscribe('stylex-update', handleStylexUpdate);\n\nexport { createHotContext, handleMessage, injectQuery, removeStyle, updateStyle };\n//# sourceMappingURL=browser.mjs.map\n":e===r.Cu?_:void 0},x({tree:t.tree}),k()({jsxRuntime:"classic",babel:{plugins:i}}),S({tree:t.tree})],c=await(0,r.nI)({plugins:l,base:`${o}/${t.ref.id}/`,cacheDir:"browser",root:n.root,resolve:{alias:n.alias}},"serve"),d=c.plugins,p=await(0,r.C4)(c),u=new r.xI(((e,n)=>p.resolveId(e,void 0,{ssr:n}))),f={on:(e,n)=>f,add(){}},h={config:c,pluginContainer:p,moduleGraph:u,transformWithEsbuild:r.TV,transformRequest:(e,n)=>(0,r.Sw)(e,h,n),ssrTransform:r.fn,printUrls(){},transformIndexHtml:null,_globImporters:{},ws:{send(n){const r=n.err;r&&(n.err=Object.assign({},r,{stack:r.stack,message:r.message})),e.publish("vite-hmr",Object.assign({},n,{ref:t.ref}))},async close(){},on(){},off(){}},middlewares:!1,app:void 0,httpServer:void 0,watcher:f,async ssrLoadModule(){},ssrFixStacktrace(){},listen:void 0,async close(){},async restart(){},_optimizeDepsMetadata:null,_isRunningOptimizer:!1,_pendingReload:void 0,_registerMissingImport:void 0,_ssrExternals:[],_restartPromise:null,_forceOptimizeOnRestart:!1,_pendingRequests:new Map};h.transformIndexHtml=(0,r.pC)(h);const m=[];for(const e of d)e.configureServer&&m.push(await e.configureServer(h));let y;m.forEach((e=>e&&e()));try{await p.buildStart({}),await async function(e,n,{ref:t,tree:o},s){const i=(n,r)=>e.publish(n,Object.assign({ref:t},r)),l=(n.config,a().join(n.config.root,"dist/__require.js"));try{n._isRunningOptimizer=!0,n._optimizeDepsMetadata=await M(0,o),n.moduleGraph.onFileChange(l)}finally{n._isRunningOptimizer=!1}n._registerMissingImport=(0,r.T3)(n,((e,t,r,a)=>M(0,o).then((e=>(n.moduleGraph.onFileChange(l),i("vite-server-status",{status:"successful"}),e))).catch((e=>(s(e),i("vite-server-status",{status:"failed"}),e)))))}(e,h,t,s)}catch(e){y=e,y.message=e.message.replace(/^Build failed with \d+ error.*:/,"Failed to start compilation server:");const{location:n}=(null==e.errors?void 0:e.errors[0])||{};n?.file&&(y.id=`${n.file}:${n?.line||0}:${n?.column||0}`,y.loc=n,y.frame=(0,r.Kp)(t.tree[(g=t.ref.id,v=n.file,v.replace(new RegExp(`(\\S+:)?/?@root/${g}`,"g"),"")).slice(1)],n))}var g,v;const b=c.createResolver;return c.createResolver=e=>{const n=b(e);return async(e,t,r,o)=>await n(e,t,r,o)},{server:h,initError:y}},P=new Map,{busid:O,wcid:j}=self,I=new class{constructor(e){this.channelName=e,this.listeners=new Map,this.broadcastChannel=new BroadcastChannel(e),this.broadcastChannel.addEventListener("message",this.onEvent.bind(this))}subscribe(e,n){let t=this.listeners.get(e);return t||(t=new Set,this.listeners.set(e,t)),t.add(n),()=>{const t=this.listeners.get(e);t&&t.delete(n)}}request(e="serve-request",n){const t=Date.now().toString(36),r=e.toString().replace("request","response");return new Promise((o=>{const s=this.subscribe(r,(e=>{e.reqId===t&&(s(),delete e.reqId,o(e.result))}));this.publish(e,{...n,reqId:t})}))}publish(e,n){this.broadcastChannel.postMessage({type:e,data:n})}onEvent(e){this.notifyListeners(e.data.type,e.data.data)}notifyListeners(e,n){const t=this.listeners.get(e);t&&t.forEach((e=>{try{e(n)}catch(e){console.error(e)}}))}}(O);async function A(e,n,t){let r;I.publish("vite-server-status",{ref:n.ref,status:"initializing"});const{server:o,initError:s}=await F(I,{cfg:e,wc:n,baseUrl:`/${I.channelName}/vite`},(e=>r.initError=e));return r={cfg:e,wc:n,server:o,initError:t||s},r}I.subscribe("tree-compilation-request",(async e=>{const{compiler_type:n,tree:t}=e;if("vite"===n){const{pkgJson:e,parseError:n}=y(t),o=P.get(j);let s=o&&!o.initError;const i=await v(t,e,j);if(function(e,n){for(const[t,r]of Object.entries(n))h(a().join(e,t),r)}(i.root,t),s){const{wc:e}=o;if(n&&(o.initError=n),JSON.stringify(i)===JSON.stringify(o.cfg)){const{server:n}=o,{root:s}=n.config;for(const o in e.tree)if(o in t){if(t[o]!==e.tree[o]){n.moduleGraph.onFileChange(a().join(s,o));try{await(0,r.qs)(a().join(s,o),t[o],n)}catch(e){n.ws.send({type:"error",err:e})}}}else(0,r.PJ)(a().join(s,o),n,!0),delete e.tree[o];for(const o in t)o in e.tree||((0,r.PJ)(a().join(s,o),n,!1),n.ws.send({type:"full-reload",path:o}),e.tree[o]=t[o])}else o.server.close(),s=!1}if(!s)try{const e=await A(i,{tree:t,ref:{id:j}},n);P.set(j,e),e.server.ws.send({type:"full-reload"}),self.postMessage({cmd:"compile-context-inited"})}catch(e){return b(I,e,j),void I.publish("tree-compile-failure",{wcid:j})}I.publish("tree-compile-success",{wcid:j,imports:[],tree:{}})}})),I.subscribe("vite-reload-request",(async({reqId:e,wcid:n})=>{const t=P.get(n);if(t){P.delete(t),t.server.close();const{wc:e}=t;try{const{pkgJson:t,parseError:r}=y(e.tree),o=await v(e.tree,t,n),s=await A(o,e,r);P.set(n,s)}catch(e){b(I,e,n)}}I.publish("vite-reload-response",{reqId:e,result:{}})})),I.subscribe("serve-request",(async({reqId:e,pathname:n,rawUrl:t,accept:s})=>{n.endsWith("/")&&(n="/index.html",s="text/html"),(n.endsWith("/d2c")||n.endsWith("/user/:userId"))&&(n="/index.html",s="text/html");let i={};try{const e=P.get(j);if(!e)throw new Error("Vite server not yet started");const{server:l,wc:c,initError:d}=e,p=s?.includes("text/html");let u,f;if(n=(0,r.zD)(n),n=(0,r.KA)(n),(0,r.bc)(n)&&s?.includes("text/css")&&(n=(0,r.Bl)(n,"direct")),f=(0,r.j$)(n)?"text/css":p?"text/html":s?.includes("image/")?function(e){const n=a().extname(e).slice(1);switch(n){case"svg":return"image/svg+xml";case"jpeg":case"jpg":return"image/jpeg";default:return`image/${n}`}}(n):"application/javascript",d&&"/@vite/client"!==n)u=E(I,f,d,j);else{let t=n;try{if(p)t=function(e,n){return n.includes(e)?e:((""===e||e.endsWith("/"))&&w(n,`${e}index`),new RegExp("\\.(mdx?|html?|astro|njk)$").test(e)?void 0:w(n,e))}(t,Object.keys(c.tree)),t?u=await l.transformIndexHtml(t,c.tree[t]):n.startsWith("/@virtual/")&&(u=await l.transformIndexHtml(n,""));else if(f.startsWith("image/")){const n=o.default.readFileSync(`${e.cfg.root}${t}`,"utf8");u=n.buffer||n}else u=(await(0,r.Sw)(n,l,{html:p}))?.code}catch(e){(function(e,n,t,r){if("vite:import-analysis"===e.plugin){const[,n,t]=e.message?.match(/Failed to resolve import '([^']+)' from '([^']+)'/)||[],[,r]=n?.match(/^((?:@[^/A-Z:]+\/)?[^@/._A-Z:~)('!*][^@/A-Z:~)('!*]*)(?:@(.+?))?(\/[^\\/].*?)?$/)||[];r&&(e.message=`Missing dependency '${r}' imported from '${t}'`)}else e.id||(r&&n[r]?e.id=`/${r}`:e.message=`Error processing ${r} ${e?.message}`)})(e,c.tree,0,n),l.ws.send({type:"error",err:e}),"text/css"!==f&&(u=E(I,f,e,j))}}if(u){const e=await caches.open("vite");await e.put(new Request(t),new Response(u,{headers:{"Content-Type":f}})),i={cache:!0,url:n}}else i={notfound:!0,url:n}}catch(e){console.log(e),i={error:e.message,url:n}}I.publish("serve-response",{reqId:e,result:i})}))},80950:()=>{},46601:()=>{},89214:()=>{},72950:()=>{},8623:()=>{},7748:()=>{},85568:()=>{},56619:()=>{},66026:()=>{},77108:()=>{},52361:()=>{},94616:()=>{}}]);
//# sourceMappingURL=211.b4f1449b7.chunk.js.map